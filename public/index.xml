<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yet Another Android Developer Blog</title>
    <link>http://andriydruk.com/</link>
    <description>Recent content on Yet Another Android Developer Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Code released under the Apache 2.0 license.</copyright>
    <lastBuildDate>Sun, 18 Oct 2015 14:36:40 +0300</lastBuildDate>
    <atom:link href="http://andriydruk.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>R.tools</title>
      <link>http://andriydruk.com/post/rtools/</link>
      <pubDate>Sun, 18 Oct 2015 14:36:40 +0300</pubDate>
      
      <guid>http://andriydruk.com/post/rtools/</guid>
      <description>&lt;p&gt;Hi everyone. Today I want to announce my new app &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.druk.rtools&#34;&gt;R.tools&lt;/a&gt;. It&amp;rsquo;s a simple application for android developers, that provides information about a device configuration.
I believe you know about android devices fragmentation and a necessity to use alternative resources to support specific device configurations. This app can help you with it.&lt;/p&gt;

&lt;p&gt;R.tools app provides a list of configuration qualifiers sorted by priority. You can check qualifiers that you are interested in and concatenate them to a resources folder name. Yes, I know that dozen of apps with similar functionality already exist on Google Play. However most of them are ugly or contain unnecessary advertisements or trackers. That&amp;rsquo;s why I&amp;rsquo;ve decided to create a clean app with a nice look. Also I see R.toors not only as tools app, but educational as well.&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34; markdown=&#34;1&#34;&gt;
    &lt;img src=&#34;http://andriydruk.com/img/Screenshot_20151018-150757.png&#34; alt=&#34;Mountain View&#34;&gt;
&lt;/div&gt;

&lt;p&gt;R.tools app provides information about all qualifiers, such as an ability to change a value or min  SDK version.&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34; markdown=&#34;1&#34;&gt;
    &lt;img src=&#34;http://andriydruk.com/img/Screenshot_001.png&#34; alt=&#34;Mountain View&#34;&gt;
&lt;/div&gt;

&lt;p&gt;And a tablet version:&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34; markdown=&#34;1&#34;&gt;
    &lt;img src=&#34;http://andriydruk.com/img/Screenshot_002.png&#34; alt=&#34;Mountain View&#34;&gt;
&lt;/div&gt;

&lt;p&gt;I hope this application will be usefull for you.&lt;/p&gt;

&lt;p&gt;Source code is available at &lt;a href=&#34;https://github.com/andriydruk/R.tools&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wrap Annoying APIs With RxJava</title>
      <link>http://andriydruk.com/post/rxdnssd/</link>
      <pubDate>Sun, 13 Sep 2015 22:51:10 +0300</pubDate>
      
      <guid>http://andriydruk.com/post/rxdnssd/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Reactive Extensions (also known as ReactiveX or Rx)&lt;/a&gt; is a library, that brings &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;FRP&lt;/a&gt; programming paradigm to different platforms. And it&amp;rsquo;s a breath of fresh air for android developers in Java 6 desert. A lot of articles about RxJava concept and common usage have already been written and I don&amp;rsquo;t want to explain it again. That&amp;rsquo;s why I would like to publish my example of RxJava usage in Android just to show you how you can wrap Java APIs. In this article I will describe a process of Java API wrapping for Appleâ€™s DNSSD library (which in my opinion is quite an annoying API).&lt;/p&gt;

&lt;p&gt;DNSSD library&amp;rsquo;s public API is a Singleton that provides static methods implementing basic operations such as searching or advertising. All operations work asynchronously and their results are returned to you in callbacks from a background thread. It&amp;rsquo;s a usual Java API. What&amp;rsquo;s wrong with it? Let&amp;rsquo;s imagine a basic usage scenario of services search in a network:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Browse service&lt;/li&gt;
&lt;li&gt;Resolve service&lt;/li&gt;
&lt;li&gt;Query records&lt;/li&gt;
&lt;li&gt;Update UI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That means that you should start &lt;code&gt;browse&lt;/code&gt; operation with a &lt;code&gt;BrowseCallback&lt;/code&gt;. In this callback you start &lt;code&gt;resolve&lt;/code&gt; with a &lt;code&gt;ResolveCallback&lt;/code&gt;, and than inside &lt;code&gt;ResolveCallback&lt;/code&gt; you start &lt;code&gt;queryRecords&lt;/code&gt; with a &lt;code&gt;QueryRecordsCallback&lt;/code&gt;. After that you send a message to the main thread, where you update your UI. This turns into &amp;lsquo;callback hell&amp;rsquo;. Real problems arise when a user leaves your app before you&amp;rsquo;ve got any results from this chain of callbacks, and you have to unsubscribe all listeners and to cancel all operations. Another big headache is exceptions handling from all operations and forwarding corresponding messages to the UI.&lt;/p&gt;

&lt;p&gt;Ok, let&amp;rsquo;s wrap this API with RxJava.&lt;/p&gt;

&lt;h2 id=&#34;intro:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Intro&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;If you aren&amp;rsquo;t familiar with RxJava, I highly recommend you to start from the &lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;official documentation&lt;/a&gt;. In this article I&amp;rsquo;m not going to explain RxJava operators, only examples of usage.&lt;/p&gt;

&lt;p&gt;Ok, firstly, let&amp;rsquo;s take a look at DNSSD Apple API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract public class DNSSD{
    public static DNSSDService  browse( int flags, int ifIndex, String regType, 
        String domain, BrowseListener listener) throws DNSSDException;

    public static DNSSDService  resolve( int flags, int ifIndex, String serviceName, 
        String regType, String domain, ResolveListener listener) throws DNSSDException;

    public static DNSSDService  queryRecord( int flags, int ifIndex, String serviceName, 
        int rrtype, int rrclass, QueryListener listener) throws DNSSDException;
}

public interface BrowseListener extends BaseListener
{
    /** Called to report discovered services.&amp;lt;P&amp;gt; */
    void    serviceFound(DNSSDService browser, int flags, int ifIndex,
                         String serviceName, String regType, String domain);

    /** Called to report services which have been deregistered.&amp;lt;P&amp;gt; */
    void    serviceLost(DNSSDService browser, int flags, int ifIndex,
                        String serviceName, String regType, String domain);


}

public interface ResolveListener extends BaseListener
{
    /** Called when a service has been resolved.&amp;lt;P&amp;gt; */
    void    serviceResolved(DNSSDService resolver, int flags, int ifIndex, String fullName,
                            String hostName, int port, TXTRecord txtRecord);
}

public interface QueryListener extends BaseListener
{
    /** Called when a record query has been completed. Inspect flags 
        parameter to determine nature of query event.&amp;lt;P&amp;gt; */
    void    queryAnswered(DNSSDService query, int flags, int ifIndex, String fullName,
                          int rrtype, int rrclass, byte[] rdata, int ttl);
}

public interface BaseListener
{
    /** Called to report DNSSD operation failures.&amp;lt;P&amp;gt; */
    void    operationFailed(DNSSDService service, int errorCode);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every method returns a &lt;code&gt;DNSSDService&lt;/code&gt; object, that contains only one method to stop this operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DNSSDService
{
    /**
    Halt the active operation and free resources associated with the DNSSDService.&amp;lt;P&amp;gt;

    Any services or records registered with this DNSSDService will be deregistered. Any
    Browse, Resolve, or Query operations associated with this reference will be terminated.&amp;lt;P&amp;gt;
    */
    void stop();
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve written an interface for &lt;code&gt;DNSSDService&lt;/code&gt;s creation  and a general method for &lt;code&gt;Observable&lt;/code&gt;s creation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DNSSDServiceCreator&amp;lt;T&amp;gt;{
    DNSSDService getService(Subscriber&amp;lt;? super T&amp;gt; subscriber) throws DNSSDException;
}

private &amp;lt;T&amp;gt; Observable&amp;lt;T&amp;gt; createObservable(DNSSDServiceCreator&amp;lt;T&amp;gt; mCreator){
    final DNSSDService[] mService = new DNSSDService[1];
    return Observable.create(new OnSubscribe&amp;lt;T&amp;gt;() {
        @Override
        public void call(Subscriber&amp;lt;? super T&amp;gt; subscriber) {
            if (!subscriber.isUnsubscribed()) {
                mContext.getSystemService(Context.NSD_SERVICE);
                try {
                    mService[0] = mCreator.getService(subscriber);
                } catch (DNSSDException e) {
                    e.printStackTrace();
                    subscriber.onError(e);
                }
            }
        }
    }).doOnUnsubscribe(() -&amp;gt; {
        if (mService[0] != null) {
            mService[0].stop();
            mService[0] = null;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use a trick with &lt;code&gt;final DNSSDService[] mService = new DNSSDService[1]&lt;/code&gt; to save &lt;code&gt;DNSSDService&lt;/code&gt; instance from &lt;a href=&#34;http://reactivex.io/RxJava/javadoc/rx/Observable.OnSubscribe.html&#34;&gt;&lt;code&gt;OnSubscribe&lt;/code&gt;&lt;/a&gt; callback and to stop it inside &lt;a href=&#34;http://reactivex.io/documentation/operators/do.html&#34;&gt;&lt;code&gt;doOnUnsubscribe&lt;/code&gt;&lt;/a&gt; operator.&lt;/p&gt;

&lt;p&gt;Before implementing basic operations I&amp;rsquo;ve created a &lt;code&gt;BonjourService&lt;/code&gt; class. The main idea is to create a chain of observables that will operate with this class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BonjourService {

    public final int flags;
    public final int ifIndex;
    public final String serviceName;
    public final String regType;
    public final String domain;

    public Map&amp;lt;String, String&amp;gt; dnsRecords = new ArrayMap&amp;lt;&amp;gt;();
    public String hostname;
    public int port;

    public BonjourService(int flags, int ifIndex, String serviceName, String regType, 
    	String domain) {
        this.flags = flags;
        this.ifIndex = ifIndex;
        this.serviceName = serviceName;
        this.regType = regType;
        this.domain = domain;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;browse:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Browse&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Ok, the first operation I&amp;rsquo;ve implemented is &lt;code&gt;browse&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable&amp;lt;BonjourService&amp;gt; browse(final String regType, final String domain) {
    return INSTANCE.createObservable(subscriber -&amp;gt; DNSSD.browse(0, DNSSD.ALL_INTERFACES, 
        regType, domain, new BrowseListener(subscriber)));
}

private static class BrowseListener implements com.apple.dnssd.BrowseListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;

    private BrowseListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber){
        mSubscriber = subscriber;
    }

    @Override
    public void serviceFound(DNSSDService browser, int flags, int ifIndex, String serviceName, 
            String regType, String domain) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onNext(new BonjourService(flags, ifIndex, serviceName, egType, domain));
    }

    @Override
    public void serviceLost(DNSSDService browser, int flags, int ifIndex, String serviceName, 
            String regType, String domain) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onNext(new BonjourService(flags | BonjourService.DELETED, ifIndex, 
            serviceName, regType, domain));
    }

    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD browse error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;browse&lt;/code&gt; is an endless operation. That&amp;rsquo;s why it never calls &lt;code&gt;onComplete&lt;/code&gt; method on a &lt;code&gt;Subscriber&lt;/code&gt;. Every time when DNSSD library calls a &lt;code&gt;serviceFound&lt;/code&gt; callback I emit a &lt;code&gt;new BonjourService&lt;/code&gt; object. Inside a &lt;code&gt;serviceLost&lt;/code&gt; callback I do the same, but with additional flag &lt;code&gt;BonjourService.DELETED&lt;/code&gt;. That&amp;rsquo;s why &lt;code&gt;Subsriber&lt;/code&gt; should always check this flag before updating of the UI.&lt;/p&gt;

&lt;p&gt;Now look at the usage of my &lt;code&gt;browse&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mSubscription = RxDNSSD.browse(mReqType, mDomain)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(bonjourService -&amp;gt; {
        if ((bonjourService.flags &amp;amp; BonjourService.DELETED) != BonjourService.DELETED) {
            mAdapter.add(bonjourService);
        } else {
            mAdapter.remove(bonjourService);
        }
        mAdapter.notifyDataSetChanged();
    }, throwable -&amp;gt; {
        Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
        showErrorMessage(throwable);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t use &lt;code&gt;subscribeOn&lt;/code&gt;, because DNSSD will create its own thread and it&amp;rsquo;s not necessary to call all DNSSD API methods from a background thread. However, I always use &lt;code&gt;observeOn&lt;/code&gt;, because all callbacks from DNSSD API will be called from a background thread.&lt;/p&gt;

&lt;h2 id=&#34;resolve:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Resolve&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Next operation is &lt;code&gt;resolve&lt;/code&gt;. I use this operation to resolve target host service name, port number, and a txt record.
Unlike &lt;code&gt;browse&lt;/code&gt; operation this one will return &lt;a href=&#34;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&#34;&gt;&lt;code&gt;Transformer&lt;/code&gt;&lt;/a&gt;, that transforms an &lt;code&gt;Observable&lt;/code&gt; of &lt;code&gt;BonjourService&lt;/code&gt; into an &lt;code&gt;Observable&lt;/code&gt; of resolved &lt;code&gt;BonjourService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First of all I&amp;rsquo;ve applied a &lt;a href=&#34;http://reactivex.io/documentation/operators/flatmap.html&#34;&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt; to income &lt;code&gt;Observalbe&lt;/code&gt;. Then in map&amp;rsquo;s function I check if &lt;code&gt;BonjourService&lt;/code&gt; contains &lt;code&gt;DELETED&lt;/code&gt; flag then I return &lt;code&gt;Observable.just(bs)&lt;/code&gt; (maybe the information about this &lt;code&gt;BonjourService&lt;/code&gt; will be usefull for a &lt;code&gt;Subsriber&lt;/code&gt;).
In another case I return new &lt;code&gt;Observable&lt;/code&gt; that will query record from DNSSD API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable.Transformer&amp;lt;BonjourService, BonjourService&amp;gt; resolve() {
    return observable -&amp;gt; observable.flatMap(bs -&amp;gt; {
        if ((bs.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
            return Observable.just(bs);
        }
        return INSTANCE.createObservable(subscriber -&amp;gt; DNSSD.resolve(bs.flags, bs.ifIndex, 
            bs.serviceName, bs.regType, bs.domain, new ResolveListener(subscriber, bs)));
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the operation finishes successfully, I will put a target host, port number, and a txt record to &lt;code&gt;BonjourService&lt;/code&gt; object and emit it to a &lt;code&gt;Subscriber&lt;/code&gt;. Unlike &lt;code&gt;browse&lt;/code&gt; operation this one is not endless, that&amp;rsquo;s why after emitting I call &lt;code&gt;onComplete&lt;/code&gt;. In the case of error, I forward this error to a &lt;code&gt;Subscriber&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static class ResolveListener implements com.apple.dnssd.ResolveListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;
    private BonjourService mBonjourService;

    private ResolveListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber, 
            BonjourService service){
        mSubscriber = subscriber;
        mBonjourService = service;
    }

    @Override
    public void serviceResolved(DNSSDService resolver, int flags, int ifIndex, 
            String fullName, String hostName, int port, TXTRecord txtRecord) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mBonjourService.port = port;
        mBonjourService.hostname = hostName;
        mBonjourService.dnsRecords.clear();
        mBonjourService.dnsRecords.putAll(parseTXTRecords(txtRecord));
        mSubscriber.onNext(mBonjourService);
        mSubscriber.onCompleted();
        resolver.stop();
    }

    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD resolve error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example of usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mSubscription = RxDNSSD.browse(mReqType, mDomain)
        .compose(RxDNSSD.resolve())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(bonjourService -&amp;gt; {
            if ((bonjourService.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
                return;
            }
            updateUI(bonjourService, true);
        }, throwable -&amp;gt; {
            Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
            showErrorMessage(throwable);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;query-records:167ce4eccbd4d3a1fceeff7ec1945355&#34;&gt;&lt;strong&gt;Query Records&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;We use &lt;code&gt;queryRecords&lt;/code&gt; to query for an arbitrary DNS record. This operation is very similar to the previous one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Observable.Transformer&amp;lt;BonjourService, BonjourService&amp;gt; queryRecords() {
    return observable -&amp;gt; observable.flatMap(bs -&amp;gt; {
        if ((bs.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
            return Observable.just(bs);
        }
        return INSTANCE.createObservable(subscriber -&amp;gt; DNSSD.queryRecord(0, bs.ifIndex, 
            bs.hostname, 1, 1, new QueryListener(subscriber, bs)));
    });
}

private static class QueryListener implements com.apple.dnssd.QueryListener{
    private Subscriber&amp;lt;? super BonjourService&amp;gt; mSubscriber;
    private BonjourService mBonjourService;

    private QueryListener(Subscriber&amp;lt;? super BonjourService&amp;gt; subscriber, 
            BonjourService bonjourService){
        mSubscriber = subscriber;
        mBonjourService = bonjourService;
    }

    @Override
    public void queryAnswered(DNSSDService query, int flags, int ifIndex, 
            String fullName, int rrtype, int rrclass, byte[] rdata, int ttl) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        try {
            InetAddress address = InetAddress.getByAddress(rdata);
            mBonjourService.dnsRecords.put(BonjourService.DNS_RECORD_KEY_ADDRESS, 
                address.getHostAddress());
            mSubscriber.onNext(mBonjourService);
            mSubscriber.onCompleted();
        } catch (Exception e) {
            mSubscriber.onError(e);
        } finally {
            query.stop();
        }
    }
    @Override
    public void operationFailed(DNSSDService service, int errorCode) {
        if (mSubscriber.isUnsubscribed()){
            return;
        }
        mSubscriber.onError(new RuntimeException(&amp;quot;DNSSD queryRecord error: &amp;quot; + errorCode));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the operation finishes sucessfully, I put a resolved address to &lt;code&gt;BonjourService&lt;/code&gt; and emit this object.&lt;/p&gt;

&lt;p&gt;Example of usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mSubscription = RxDNSSD.browse(mReqType, mDomain)
        .compose(RxDNSSD.resolve())
        .compose(RxDNSSD.queryRecords())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(bonjourService -&amp;gt; {
            if ((bonjourService.flags &amp;amp; BonjourService.DELETED) == BonjourService.DELETED) {
                return;
            }
            updateUI(bonjourService, true);
        }, throwable -&amp;gt; {
            Log.e(&amp;quot;DNSSD&amp;quot;, &amp;quot;Error: &amp;quot;, throwable);
            showErrorMessage(throwable);
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating of Rx chains is very usefull because you don&amp;rsquo;t need to care about canceling of all operations and listeners removal. The only thing you have to do inside your &lt;code&gt;onPause&lt;/code&gt;||&lt;code&gt;onStop&lt;/code&gt;||&lt;code&gt;onDestroy&lt;/code&gt; methods is to call &lt;code&gt;mSubscription.cancel()&lt;/code&gt;. Another big advantage is the ability to handle all exceptions from a chain in one place.&lt;/p&gt;

&lt;p&gt;You can find a usage of the described wrapper (I&amp;rsquo;ve named it &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser/blob/master/app/src/main/java/com/druk/bonjour/browser/dnssd/RxDNSSD.java&#34;&gt;&lt;code&gt;RxDNSSD&lt;/code&gt;&lt;/a&gt;) in my project &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser&#34;&gt;Bonjour Browser&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all. Happy wrapping annoying APIs!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bonjour in Android applications</title>
      <link>http://andriydruk.com/post/mdnsresponder/</link>
      <pubDate>Sat, 05 Sep 2015 14:14:19 +0300</pubDate>
      
      <guid>http://andriydruk.com/post/mdnsresponder/</guid>
      <description>&lt;p&gt;&lt;strong&gt;What is Bonjour?&lt;/strong&gt;
Wiki definition of Bonjour is&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour is Apple&amp;rsquo;s implementation of Zero-configuration networking (Zeroconf), a group of technologies that includes service discovery, address assignment, and hostname resolution. Bonjour locates devices such as printers, other computers, and the services that those devices offer on a local network using multicast Domain Name System (mDNS) service records.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apple definition is&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Bonjour, also known as zero-configuration networking, enables automatic discovery of devices and services on a local network using industry standard IP protocols. Bonjour makes it easy to discover, publish, and resolve network services with a sophisticated, yet easy-to-use, programming interface that is accessible from Cocoa, Ruby, Python, and other languages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, Bonjour is a software component that is used for other devices discovery (PC, Mac, smartphones, printers, etc) in a network via all available interfaces. A Bonjour term for a device on a network is &amp;ldquo;service&amp;rdquo;. Any application in your operating system can register a service and assign it to an opened port on your computer (actually Bonjour does not guarantee that a port in service&amp;rsquo;s metadata is opened and connected to the app that registered this service). All services are registered in some domain (that&amp;rsquo;s a mandatory parameter for all services and you can find domain naming conventions &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/domainnames.html&#34;&gt;here&lt;/a&gt;). Also applications can discover all available services at any domain. You should understand that Bonjour is only a technology for services discovery, all connection you have to do by yourself anyway.&lt;/p&gt;

&lt;p&gt;You can find more information about Bonjour in &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Introduction.html&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What about Android? Can we use this powerful technology in our Android projects?&lt;/strong&gt; Yes. Google uses this technology in lots of their projects. For example: you try to connect to Chromecast in your living room - it&amp;rsquo;s Bonjour. You are playing games with your friends via wifi - it&amp;rsquo;s Bonjour. You print documents via wifi on your printer - Bonjour is here again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Is there a standard Android API for it?&lt;/strong&gt; Yes. Google provides &lt;a href=&#34;http://developer.android.com/training/connect-devices-wirelessly/nsd.html&#34;&gt;Network Service Discovery API&lt;/a&gt; that uses the same technology Apple uses in Mac OS X and iOS (Oh, I&amp;rsquo;ve forgotten to tell you that Bonjour is open-source). This API is available starting from API level 16 (Android 4.1) and works well in general, though it doesn&amp;rsquo;t cover all Bonjour functionality. One of the most important parts of Bonjour API is ability to share some metadata about a service, also known as TXT records.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s what &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NetServices/Articles/NetServicesArchitecture.html&#34;&gt;official documentation&lt;/a&gt; says about it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TXT record has the same name as the corresponding SRV record, and can contain a small amount of additional information about the service instance, typically no more than 100â€“200 bytes at most. This record may also be empty. For example, a network game could advertise the name of the map being used in a multiplayer game, and a chat program could advertise the availability of the user (for example, idle, away, or available). If you need to transmit larger amounts of data, the host should establish a connection with the client and send the data directly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This feature can be very useful and I don&amp;rsquo;t understand why it isn&amp;rsquo;t available in the official SDK. There is no technical reason for this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Are there any other options?&lt;/strong&gt; Yes, another option for Android developers is &lt;a href=&#34;http://jmdns.sourceforge.net&#34;&gt;jmDNS&lt;/a&gt; library. It&amp;rsquo;s an open-source library written in Java 1.6 (this matters for Android developers) and it&amp;rsquo;s compatible with Apple&amp;rsquo;s Bonjour. You can use it at any Android API level and this library supports TXT records. Yet I do have some issues with jmDNS (I got a few crashes inside jmDNS from Crashlytcics, and I have no idea how I can fix it) and it works pretty slow.&lt;/p&gt;

&lt;p&gt;Also Google (not Android open source project) has introduced a new cross-platform library &lt;a href=&#34;https://developers.google.com/nearby/&#34;&gt;Google Nearby API&lt;/a&gt;. Its API consists of two conceptually different APIs: Nearby Messages API and Nearby Connections API. Message API can be used for services discovering via all available interfaces (Wifi, Wifi-direct, Bluetooth 2.0 and LE) and connecting two or more devices via Internet. Actually this is a very interesting idea in time of fast mobile internet (I might write more about it in another article). And Connections API can be used for discovering and connecting via wifi interface. Actually it&amp;rsquo;s a really good solution. You don&amp;rsquo;t need to bother with sockets, ports, discovering, connections and multithreading. All these have already been done for you. But this solution works only with Android and iOS, and it&amp;rsquo;s not open-source (that&amp;rsquo;s why I emphasize that it&amp;rsquo;s a Google project). If you want to discover some services from another system or your app works with other libraries (for example: printers or vnc servers) you should look for other options.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you know any other options?&lt;/strong&gt; Yes, and that&amp;rsquo;s why I&amp;rsquo;m writing this article. I have good news for you: you can just get Apple&amp;rsquo;s implementation of Bonjour and use it in your Android project.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WHAAAAAAT? Apple&amp;rsquo;s libraries in Android project?&lt;/strong&gt; Yes, it&amp;rsquo;s called mDnsResponder and it has been written in C many years ago (actually Apple has bought it). Here is its architecture overview from &lt;a href=&#34;http://opensource.apple.com/source/mDNSResponder/mDNSResponder-66.3/README.txt?txt&#34;&gt;documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A typical mDNS program contains three components:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.com/img/Screen Shot 2015-09-05 at 23.21.23.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &amp;ldquo;mDNS Core&amp;rdquo; layer is absolutely identical for all applications and
all Operating Systems.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Platform Support&amp;rdquo; layer provides the necessary supporting routines
that are specific to each platform &amp;ndash; what routine do you call to send
a UDP packet, what routine do you call to join multicast group, etc.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Application&amp;rdquo; layer does whatever that particular application wants
to do. It calls routines provided by the &amp;ldquo;mDNS Core&amp;rdquo; layer to perform
the functions it needs &amp;ndash;
 * advertise services,
 * browse for named instances of a particular type of service
 * resolve a named instance to a specific IP address and port number,
 * etc.
The &amp;ldquo;mDNS Core&amp;rdquo; layer in turn calls through to the &amp;ldquo;Platform Support&amp;rdquo;
layer to send and receive the multicast UDP packets to do the actual work.&lt;/p&gt;

&lt;p&gt;Apple currently provides &amp;ldquo;Platform Support&amp;rdquo; layers for Mac OS 9, Mac OS X,
Microsoft Windows, VxWorks, and for POSIX platforms like Linux, Solaris,
FreeBSD, etc.&lt;/p&gt;

&lt;p&gt;Note: Developers writing applications for OS X do not need to incorporate
this code into their applications, since OS X provides a system service to
handle this for them. If every application developer were to link-in the
mDNSResponder code into their application, then we would end up with a
situation like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.com/img/Screen Shot 2015-09-05 at 23.21.31.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This would not be very efficient. Each separate application would be sending
their own separate multicast UDP packets and maintaining their own list of
answers. Because of this, OS X provides a common system service which client
software should access through the &amp;ldquo;/usr/include/dns_sd.h&amp;rdquo; APIs.&lt;/p&gt;

&lt;p&gt;The situation on OS X looks more like the picture below:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://andriydruk.com/img/Screen Shot 2015-09-05 at 23.21.39.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Applications on OS X make calls to the single mDNSResponder daemon
which implements the mDNS and DNS-SD protocols.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In fact Android uses the same solution in one system daemon and lots of applications. The daemon is available for developers since API 16 (Android 4.1) and you can connect to it from a native level via dns-sd.h.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;But I don&amp;rsquo;t know C/C++! Do you have any Java wrapper for it?&lt;/strong&gt; No, but Apple does. Let&amp;rsquo;s compile it together. First of all you need to compile mDnsResponder native client. You can find its source code &lt;a href=&#34;https://android.googlesource.com/platform/external/mdnsresponder/&#34;&gt;here&lt;/a&gt;. It&amp;rsquo;s a part of Android open-source project and it&amp;rsquo;s updated from time to time, but it is completely independent library that works through POSIX API. I believe, that you can use any version of it with any version of Android. Also you should add JNI bridge to this native source code. Just go to dns-sd.h file and look for version of mDNSResponer. In my case it is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* _DNS_SD_H contains the mDNSResponder version number for this header file, formatted as follows:
 *   Major part of the build number * 10000 +
 *   minor part of the build number *   100
 * For example, Mac OS X 10.4.9 has mDNSResponder-108.4, which would be represented as
 * version 1080400. This allows C code to do simple greater-than and less-than comparisons:
 * e.g. an application that requires the DNSServiceGetProperty() call (new in mDNSResponder-126) can check:
 *
 *   #if _DNS_SD_H+0 &amp;gt;= 1260000
 *   ... some C code that calls DNSServiceGetProperty() ...
 *   #endif
 *
 * The version defined in this header file symbol allows for compile-time
 * checking, so that C code building with earlier versions of the header file
 * can avoid compile errors trying to use functions that aren&#39;t even defined
 * in those earlier versions. Similar checks may also be performed at run-time:
 *  =&amp;gt; weak linking -- to avoid link failures if run with an earlier
 *     version of the library that&#39;s missing some desired symbol, or
 *  =&amp;gt; DNSServiceGetProperty(DaemonVersion) -- to verify whether the running daemon
 *     (&amp;quot;system service&amp;quot; on Windows) meets some required minimum functionality level.
 */

#ifndef _DNS_SD_H
#define _DNS_SD_H 3201080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It means that mDNSResponder version is 320.10.80. Now go to &lt;a href=&#34;http://opensource.apple.com/tarballs/mDNSResponder/&#34;&gt;Apple Open Source&lt;/a&gt; site and find this version. Unzip downloaded archive and find folder /mDNSShared/Java/. Copy JNISupport.c file to your jni folder and all *.java files to your scr folder. Then add JNISupport to Android.mk file, in my case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;LOCAL_SRC_FILES :=  mDNSShared/dnssd_clientlib.c  \
                    mDNSShared/dnssd_clientstub.c \
                    mDNSShared/dnssd_ipc.c \
                    mDNSShared/JNISupport.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all. Compile the native code with &amp;lsquo;ndk-build&amp;rsquo; command and then build your Android project.&lt;/p&gt;

&lt;p&gt;And one more thing: Android can stop the daemon to save battery or for some other reason(if it&amp;rsquo;s not used for example). That&amp;rsquo;s why you should call next method before working with any code from com.apple.dnssd.*.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;context.getSystemService(Context.NSD_SERVICE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, mDNSResponder will throw a checked exception &amp;ldquo;DNSD-SD Daemon not available&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you have any examples?&lt;/strong&gt; Yep, you can find an example of mDNSResponder usage (containing compiled native libraries with  the latest ndk version for all architectures) in my project Bonjour Browser, all code is available on &lt;a href=&#34;https://github.com/andriydruk/BonjourBrowser&#34;&gt;GitHub&lt;/a&gt;. You can also see it in action in &lt;a href=&#34;https://play.google.com/store/apps/details?id=com.druk.bonjour.browser&amp;amp;hl=uk&#34;&gt;Google Play.&lt;/a&gt; It works really fast!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>http://andriydruk.com/post/about/</link>
      <pubDate>Tue, 07 Jul 2015 23:10:36 +0300</pubDate>
      
      <guid>http://andriydruk.com/post/about/</guid>
      <description>

&lt;!--&lt;
div style=&#34;text-align:center&#34; markdown=&#34;1&#34;&gt;
    &lt;img src=&#34;http://andriydruk.com/img/welcome_bg.jpg&#34; alt=&#34;my photo&#34;&gt;
&lt;/div&gt;
--&gt;

&lt;p&gt;Hello everyone and welcome to &lt;a href=&#34;andriydruk.com&#34;&gt;Yet Another Android Developer Blog&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve thought a lot about creating a blog about software development in the past. As a true engineer I spent a huge amount of time reviewing existing blogger platforms and static website generators, and finally, I&amp;rsquo;ve started to write articles. But first things first&amp;hellip;&lt;/p&gt;

&lt;p&gt;First of all a few words about myself. I am a software engineer from Ukraine. Ever since I was in high school, I was interested in mathematics and programming. I received a master&amp;rsquo;s degree in Software Engineering from &lt;a href=&#34;http://www.kpi.kharkov.ua/en/&#34;&gt;Kharkiv Polytechnic Institute&lt;/a&gt;. At the moment, I hold a position of &lt;a href=&#34;https://www.linkedin.com/profile/view?id=156417157&#34;&gt;Android Team Lead&lt;/a&gt; in Kharkiv (Ukraine).&lt;/p&gt;

&lt;p&gt;As you may know, the mobile development is currently one of the most promising trends in the industry. From my point of view, it is also one of the most interesting ones. In my professional career, I faced with projects for different mobile platforms, but still my passion is Android.&lt;/p&gt;

&lt;p&gt;Android is an amazing system. It&amp;rsquo;s really flexible, rich with APIs and rapidly developing. In this blog I would like to share with you some software design patterns, overviews of new technologies or just my thoughts about the industry.&lt;/p&gt;

&lt;p&gt;I really hope that this blog will be a source of useful information for you and it will help you in your future development. And of course I&amp;rsquo;m interested in your feedback, so feel free to comment on the articles.&lt;/p&gt;

&lt;p&gt;Perhaps you might be interested in some of my tools for developers that I publish in the &lt;a href=&#34;https://play.google.com/store/apps/developer?id=Andriy+Druk&#34;&gt;Google Play&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;contact-me:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Contact me&lt;/h2&gt;

&lt;p&gt;Feel free to contact me&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;mailto:andriy.druk@gmail.com&#34;&gt;andriy.druk@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/AndriyDruk&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/andriydruk&#34;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/andriy-druk-23147344&#34;&gt;LinkedIn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;about-this-blog:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;About this blog&lt;/h2&gt;

&lt;p&gt;This blog built with &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; on &lt;a href=&#34;https://pages.github.com&#34;&gt;Github pages&lt;/a&gt;. It&amp;rsquo;s a like breathe of fresh air for me after Jekyll and Octopress. Special thanks to my editor - &lt;a href=&#34;https://github.com/tolikcode&#34;&gt;Tolik Code&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;license:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;All articles and code are published under the Apache License&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>